<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mcokos Blog</title>
  
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-27T05:08:33.765Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mcokos</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View事件传递过程</title>
    <link href="http://example.com/2023/04/27/view-transform/"/>
    <id>http://example.com/2023/04/27/view-transform/</id>
    <published>2023-04-27T04:17:43.000Z</published>
    <updated>2023-04-27T05:08:33.765Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;事件传递过程&quot;&gt;事件传递过程&lt;/h3&gt;
&lt;p&gt;​
实际上，当我们手指触摸屏幕的时候，事件最先是传递给当前的&lt;code&gt;Actvity&lt;/code&gt;，由&lt;code&gt;Actvity&lt;/code&gt;的&lt;code&gt;dispatchTouchEvent&lt;/code&gt;方法来分发事件，而&lt;code&gt;Actvity&lt;/code&gt;会将事件传递给&lt;code&gt;Window&lt;/code&gt;对象来分发，&lt;code&gt;Window&lt;/code&gt;对象再传递给&lt;code&gt;DecorView&lt;/code&gt;,&lt;code&gt;DecorView&lt;/code&gt;则是我们在Actvity中通过&lt;code&gt;setContentView&lt;/code&gt;后所设置的布局的父容器，通过&lt;code&gt;getWindow().getDecorView().findViewById(android.R.id.content).getChildAt(0)&lt;/code&gt;这个方式就能获取到Activity所设置的布局。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="android" scheme="http://example.com/tags/android/"/>
    
    <category term="事件传递" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit的具体网络流程</title>
    <link href="http://example.com/2023/04/27/retrofit-detail/"/>
    <id>http://example.com/2023/04/27/retrofit-detail/</id>
    <published>2023-04-27T04:11:26.000Z</published>
    <updated>2023-04-27T05:06:24.254Z</updated>
    
    
    <summary type="html">&lt;h3&gt;
Retrofit2.0的具体网络流程
&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;通过解析网络请求接口的注解 获得 网络请求参数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 动态代理 生成网络请求对象&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 网络请求适配器 将 网络请求对象 进行平台适配&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平台包括：Android、Rxjava、Guava和java8&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 网络请求执行器 发送网络请求&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 数据转换器 解析服务器返回的数据&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 回调执行器 切换线程（子线程 -&amp;gt;&amp;gt;主线程）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户在主线程处理返回结果&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;
Retrofit实例创建
&lt;/h3&gt;</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="android" scheme="http://example.com/tags/android/"/>
    
    <category term="retrofit" scheme="http://example.com/tags/retrofit/"/>
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>沉浸式状态栏的实现方式</title>
    <link href="http://example.com/2023/04/27/Androidchengjing/"/>
    <id>http://example.com/2023/04/27/Androidchengjing/</id>
    <published>2023-04-27T02:54:54.000Z</published>
    <updated>2023-04-27T03:44:00.811Z</updated>
    
    
    <summary type="html">沉浸式状态栏的实现方式有两种&lt;br /&gt;</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="android" scheme="http://example.com/tags/android/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
